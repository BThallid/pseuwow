#include <winsock.h>
#include <time.h>
#include "zlib/zlib.h"
#include "common.h"
#include "PseuWoW.h"
#include "Auth/AuthCrypt.h"
#include "../shared/CircularBuffer.h" // to have the Buf data structure
#include "../shared/SDLTCPConnection.h"
#include "Auth/ByteBuffer.h"
#include "Auth/BigNumber.h"
#include "Auth/Sha1.h"
#include "Opcodes.h"
#include "WorldPacketHandler.h"
#include "SharedDefines.h"
#include "Player.h"
#include "NameTables.h"
#include "CMSGConstructor.h"
#include "DefScript/DefScript.h"


struct ClientPktHeader
{
    uint16 size;
    uint16 cmd;
	uint16 nil;
};

struct ServerPktHeader
{
    uint16 size;
    uint16 cmd;
};

AuthCrypt _crypt;
BigNumber sessionkey;

uint8 GetCompressedGuidSize(uint8 mask){
    uint8 size=0;
    for(unsigned int i=0;i<8;i++){
        if(mask>>i){
            size++;
        }
    }
    return size;
}

uint64 DecompressGuid(uint8 *z, uint8 mask){
    uint64 guid=0;
    for(uint8 i=0;i<8;i++){
        if(mask>>i){
            ((uint8*)&guid)[i]=*z;
            z++;
        }
    }
    return guid;
}


void SendWorldPacket(uint16 opcode, ByteBuffer *pkt){
	ClientPktHeader hdr={0,0,0};
	ByteBuffer buf;
	if(pkt!=NULL)buf.append(*pkt);
	hdr.cmd=opcode;
	hdr.size=ntohs(buf.size()+4);
	_crypt.EncryptSend((uint8*)&hdr, 6);
	ByteBuffer final;
	final.append((uint8*)&hdr,6);
	if(buf.size()){
		final.append(buf);
	}
	worldCon.Send((char*)final.contents(), final.size()); 
}


void HandleWorldPacket(ByteBuffer pkt){

	static uint16 _last_cmd,_last_remaining;
    static bool _last_pkt_wrong;
	ServerPktHeader hdr;
	uint16 _remaining, _cmd;
	ByteBuffer wdata;
	pkt >> hdr.size >> hdr.cmd;
	_crypt.DecryptRecv((uint8*)&hdr, 4);
	_remaining=ntohs(hdr.size)-2;
	_cmd=hdr.cmd;
	//DEBUG3(printf("DECRYPT: rest=%d, opcode=%d\n",_remaining,_cmd);)
	if(_cmd>800){
		DEBUG3(printf("Recieved weird opcode [%u] pktsize=%u remaining=%u(corrupted header?)\n",_cmd,pkt.size(),_remaining);)
		DEBUG3(pkt.hexlike();)
		//if(pkt.size()==_last_remaining){
		//	DEBUG3(printf("Trying to attach packet to last recieved opcode [%s], size=%u\n",LookupName(_last_cmd,g_worldOpcodeNames),_last_remaining);)
		//	wdata.append(pkt.contents(),_last_remaining);
		//	HandleOpcode(_last_cmd,wdata); // lets hope it wont crash :/
		//} else
            //DEBUG1(printf("Packet rescue failed, dropping. size=%u opcode=%u\n",_remaining,_cmd);)

		return;
	}
    else
	if(pkt.size()>4 && _remaining+4==pkt.size()){
		DEBUG3(printf("Rcvd pkt hdr is too big (%u)! Assuming {header+data}, opcode=%d [%s]\n",pkt.size(),_cmd,LookupName(_cmd,g_worldOpcodeNames));)
		wdata.append(&pkt.contents()[4],4);
		//wdata.hexlike();
		_last_cmd=_cmd;
		_last_remaining=_remaining;
		HandleOpcode(_cmd,wdata);
			
	} else {
        if(!_remaining){
            ByteBuffer dummy;
            HandleOpcode(_cmd,dummy);
        }
		if(_remaining){
			ByteBuffer content;
			content.append(worldCon.GetDataString()); // fetch the next packet
			content.resize(content.size()-1); // remove the \0
			if(content.size()<_remaining ){ // packet is smaller then expected
				//content.hexlike();
				DEBUG3(printf("Packet was smaller then expected! (expected: %u, recvd: %u)\n",_remaining,content.size());)
                //if(content.size()==_last_remaining){
                //    DEBUG3(printf("Trying to attach packet to last recieved opcode [%s], size=%u\n",LookupName(_last_cmd,g_worldOpcodeNames),_last_remaining);)
				//    wdata.append(pkt.contents(),_last_remaining);
				//    HandleOpcode(_last_cmd,wdata); // lets hope it wont crash :/
				//    //something_went_wrong=true;
                //} else
                //    printf("Packet rescue failed, dropping. size=%u opcode=%u\n",_remaining,_cmd);
				return;
			} else { // packet seems ok, use the full packet that came in
				//content.hexlike();
				wdata.append(content.contents(),_remaining);
				_last_cmd=_cmd;
				_last_remaining=_remaining;
				HandleOpcode(_cmd,wdata);
			}
		}
	}
}

void HandleOpcode(uint16 opcode, ByteBuffer &data){

	//DEBUG3(printf("W: opcode=0x%X | %d , datasize=%d  [%s]\n",opcode,opcode,data.size(),LookupName(opcode,g_worldOpcodeNames));)
	switch(opcode){
		case SMSG_AUTH_CHALLENGE:{
			std::string acc(strupr(accname));
			uint32 serverseed;
			data>>serverseed;
			DEBUG3(printf("W:auth: serverseed=0x%X\n",serverseed);)
			Sha1Hash digest;
			digest.UpdateData(acc);
			uint32 unk=0;
			digest.UpdateData((uint8*)&unk,sizeof(uint32));
			BigNumber clientseed;
			clientseed.SetRand(8*4);
			unsigned int clientseed_uint32=clientseed.AsDword();
			digest.UpdateData((uint8*)&clientseed_uint32,sizeof(uint32));
			digest.UpdateData((uint8*)&serverseed,sizeof(uint32));
			digest.UpdateBigNumbers(&sessionkey,NULL);
			digest.Finalize();
			ByteBuffer outpkt;
			outpkt<<(uint32)clientbuild<<unk<<acc<<clientseed_uint32;
			outpkt.append(digest.GetDigest(),20);
			// recvPacket << real_size
			// recvPacket << ziped_UI_Plugins_Info
			// TODO: add addon data, simulate no addons.
			outpkt<<(uint32)0; // no addons? no idea, but seems to work. MaNGOS doesnt accept without this.

			DEBUG3(
				printf("CMSG_AUTH_SESSION=");
				printchex((char*)outpkt.contents(),outpkt.size(),true);
			)
				SendWorldPacket(CMSG_AUTH_SESSION,&outpkt);
				_crypt.SetKey(sessionkey.AsByteArray(), 40);
				_crypt.Init();
		}break;
		
		case SMSG_AUTH_RESPONSE:{
			uint8 errcode;
			data>>errcode;
			if(errcode==0xC){
				DEBUG1(printf("World Authentication successful, preparing for char list request...\n"););
				SendWorldPacket(CMSG_CHAR_ENUM,NULL);
			} else {
				printf("World Authentication failed, errcode=0x%X\n",(unsigned char)errcode);
			}
		}break;

		case SMSG_CHAR_ENUM:{
			uint8 num;
			Player plr[10];
			uint8 dummy8;
			uint32 dummy32;

			data >> num;
			if(num==0){
				printf("W:No chars found!\n");
				something_went_wrong=true;
				return;
			}
			printf("W: Chars in list: %u\n",num);
			for(unsigned int i=0;i<num;i++){
				data >> plr[i]._guid;
				data >> plr[i]._name;
				data >> plr[i]._race;
				data >> plr[i]._class;
				data >> plr[i]._gender;
				data >> plr[i]._bytes1;
				data >> plr[i]._bytes2;
				data >> plr[i]._bytes3;
				data >> plr[i]._bytes4;
				data >> plr[i]._bytesx;
				data >> plr[i]._level;
				data >> plr[i]._zoneId;
				data >> plr[i]._mapId;
				data >> plr[i]._x;
				data >> plr[i]._y;
				data >> plr[i]._z;
				data >> plr[i]._guildId;
				data >> dummy8;
				data >> plr[i]._flags;
				data >> dummy8 >> dummy8 >> dummy8;
				data >> plr[i]._petInfoId;
				data >> plr[i]._petLevel;
				data >> plr[i]._petFamilyId;
				for(unsigned int inv=0;inv<20;inv++){
					data >> dummy32 >> dummy8; // item data are not relevant yet ( (uint32)itemID , (uint8)inventorytype )
				}
                plrNameCache.AddInfo(plr[i]._guid, plr[i]._name);
			}
			bool char_found=false;
			uint64 login_guid;
			for(unsigned int i=0;i<num;i++){
				printf("## %s (%u) [%s/%s]\n",
					plr[i]._name.c_str(),plr[i]._level,raceName[plr[i]._race],className[plr[i]._class]);
				DEBUG1(printf("-> coords: map=%u zone=%u x=%f y=%f z=%f\n",
					plr[i]._mapId,plr[i]._zoneId,plr[i]._x,plr[i]._y,plr[i]._z);)
				if(plr[i]._name==charname){
					char_found=true;
					login_guid=plr[i]._guid;
				}

			}
			if(!char_found){
				printf("W: Character \"%s\" was not found on char list!\n",charname.c_str());
				something_went_wrong=true;
				return;
			} else {
				printf("W: Entering World with Character \"%s\"...\n",charname.c_str());
				ByteBuffer pkt;
				pkt << login_guid;
                _myGUID=login_guid;
                _targetGUID=0;
				SendWorldPacket(CMSG_PLAYER_LOGIN,&pkt);
			}

				

		}break;

		case SMSG_ACCOUNT_DATA_MD5:
        case SMSG_SET_PROFICIENCY:
        case SMSG_CAST_RESULT:
        case SMSG_LOGIN_SETTIMESPEED: //those opcodes are sent on login
        {
            if(!inworld){
                inworld=true;
                defScp.RunScriptByName("_enterworld",NULL,255);
            }
			// o_O
		} break;

		case SMSG_MESSAGECHAT:{
			uint8 type=0;
			uint32 lang=0;
			uint64 target_guid=0;
			uint32 msglen=0;
			std::string msg,ext;
            bool isCmd=false;
		
			data >> type >> lang;
			
			if (type == CHAT_MSG_CHANNEL)
			    data >> ext; // extract channel name
			 
			data >> target_guid;
            std::string plrname;
            if(target_guid){
                plrname=plrNameCache.GetName(target_guid);
                if(plrname.empty())
                {
                    QueryPlayerName(target_guid);
                    plrname="Unknown Entity";
                }
            }
			defScp.variables.Set("@lastmsg_name",defScp.variables.Get("@thismsg_name"));
			defScp.variables.Set("@lastmsg",defScp.variables.Get("@lastmsg"));
			defScp.variables.Set("@thismsg_name",plrname);
			defScp.variables.Set("@thismsg",toString(target_guid));
			
			
			if(type == CHAT_MSG_SAY || type == CHAT_MSG_YELL || type == CHAT_MSG_PARTY)
				data >> target_guid;
			
			data >> msglen >> msg;
			if (type == CHAT_MSG_SYSTEM){
				printf("W:SYSMSG: \"%s\"\n",msg.c_str());
			} else if (type==CHAT_MSG_WHISPER ){
                printf("W:WHISP: %s [%s]: %s\n",plrname.c_str(),LookupName(lang,langNames),msg.c_str());                
            } else {
                printf("W:CHAT: %s [%s]: %s\n",plrname.c_str(),LookupName(lang,langNames),msg.c_str());
			}

            if(target_guid!=_myGUID && msg.length()>1 && msg.at(0)=='-')
                isCmd=true;

            // some fun code :P
            if(type==CHAT_MSG_SAY && target_guid!=_myGUID && !isCmd)
            {           
                if(msg=="lol")
                    SendChatMessage(CHAT_MSG_SAY,lang,"say \"lol\" if you have nothing else to say... lol xD","");
                else if(msg.length()>4 && msg.find("you?")!=std::string::npos)
                    SendChatMessage(CHAT_MSG_SAY,lang,std::string(ver).append(" -- i am a bot, made by False.Genesis, my master."),"");
                else if(msg=="hi")
                    SendChatMessage(CHAT_MSG_SAY,lang,"Hi, wadup?",""); 
                else if(msg.length()<12 && msg.find("wtf")!=std::string::npos)
                    SendChatMessage(CHAT_MSG_SAY,lang,"Yeah, WTF is a good way to say you dont understand anything... :P","");
                else if(msg.length()<15 && (msg.find("omg")!=std::string::npos || msg.find("omfg")!=std::string::npos) )
                    SendChatMessage(CHAT_MSG_SAY,lang,"OMG a bot logged in, you don't believe it :O","");
                else if(msg.find("from")!=std::string::npos || msg.find("download")!=std::string::npos)
                    SendChatMessage(CHAT_MSG_SAY,lang,"you can dl me from http://my.opera.com/PseuWoW","");
                else if(msg.find("Genesis")!=std::string::npos || msg.find("genesis")!=std::string::npos)
                    SendChatMessage(CHAT_MSG_YELL,lang,"False.Genesis, they are calling you!! Come here, master xD","");            
            }

            if(isCmd){
				defScp.variables.Set("@lastcmd_name",defScp.variables.Get("@thiscmd_name"));
				defScp.variables.Set("@lastcmd",defScp.variables.Get("@lastcmd"));
				defScp.variables.Set("@thiscmd_name",plrname);
				defScp.variables.Set("@thiscmd",toString(target_guid));
                std::string lin=msg.substr(1,msg.length()-1);
                uint8 perm=atoi(playerPermissions.Get(plrname).c_str());
                try{
                    if(!defScp.RunSingleLine(lin,perm))
				        defScp.RunScriptByName("_nopermission",NULL,255);
                } catch (...) {
                    SendChatMessage(CHAT_MSG_SAY,0,"Exception while trying to execute: [ "+lin+" ]","");
                }
                
            }
            if(type==CHAT_MSG_WHISPER && !isCmd){
				defScp.variables.Set("@lastwhisper_name",defScp.variables.Get("@thiswhisper_name"));
				defScp.variables.Set("@lastwhisper",defScp.variables.Get("@thiswhisper"));
				defScp.variables.Set("@lastwhisper_lang",defScp.variables.Get("@thiswhisper_lang"));
                defScp.variables.Set("@thiswhisper_name",plrname);
				defScp.variables.Set("@thiswhisper",toString(target_guid));
                defScp.variables.Set("@thiswhisper_lang",toString((uint64)lang));
                defScp.RunScriptByName("_onwhisper",NULL,255);
            }
			


		} break;
		
		case SMSG_MONSTER_MOVE:{
			// register moving mobs, etc
		} break;

		case SMSG_STOP_MIRROR_TIMER:{
			// mangos spams u with that if you are dead (bug)
		} break;

        case SMSG_NAME_QUERY_RESPONSE:{
            uint64 pguid;
            std::string pname;
            data >> pguid >> pname;
            if(pname.length()>12 || pname.length()<2)
                break; // playernames maxlen=12
            // rest of the packet is not interesting for now
            if(plrNameCache.AddInfo(pguid,pname))
            {
                printf("CACHE: Assigned new player name: '%s'",pname.c_str());
                SendChatMessage(CHAT_MSG_SAY,0,"Player "+pname+" added to cache.","");
                DEBUG2(printf(" to guid "I64FMTD,pguid););
                printf("\n");
            }

        } break;

        case MSG_MOVE_SET_FACING:
        case MSG_MOVE_START_FORWARD:
        case MSG_MOVE_START_BACKWARD:
        case MSG_MOVE_STOP:
        case MSG_MOVE_START_STRAFE_LEFT:
        case MSG_MOVE_START_STRAFE_RIGHT:
        case MSG_MOVE_STOP_STRAFE:
        case MSG_MOVE_JUMP:
        case MSG_MOVE_START_TURN_LEFT:
        case MSG_MOVE_START_TURN_RIGHT:
        case MSG_MOVE_STOP_TURN:
        case MSG_MOVE_START_SWIM:
        case MSG_MOVE_STOP_SWIM:
        case MSG_MOVE_HEARTBEAT:
        case MSG_MOVE_FALL_LAND:
        {
            uint32 flags, time;
            float x, y, z, o;
            uint64 guid;
            uint8 mask,guidlen,*zguid;
            std::string plrname;
            data >> mask;
            guidlen=GetCompressedGuidSize(mask);
            zguid=new uint8[guidlen];
            data.read(zguid,guidlen);
            guid=DecompressGuid(zguid,mask);
            delete zguid;
            data >> flags >> time >> x >> y >> z >> o;
            if(guid){
                plrname=plrNameCache.GetName(guid);
                if(plrname.empty())
                {
                    QueryPlayerName(guid);
                    plrname="Unknown Entity";
                }
            }
            // for follow:
            if(_followGUID==guid){
                ByteBuffer bb;
                bb << time << flags << x << y << z << o;
                SendWorldPacket(opcode,&bb);
            }
            // more to come
        } break;

        case SMSG_PONG:{
            uint32 pong;
            data >> pong;
            printf("Recieved Ping reply: %u ms latency, including %u ms fetch delay.\n",clock()-pong,idleSleepTime);
        } break;

        case SMSG_TRADE_STATUS:{
            data.hexlike();
            uint8 unk;
            data >> unk;
            if(unk==1){
            SendChatMessage(CHAT_MSG_SAY,0,"It has no sense trying to trade with me, that feature is not yet implemented!","");
            SendWorldPacket(CMSG_CANCEL_TRADE,NULL);
            }
        }

        case SMSG_GROUP_INVITE:{
            data.hexlike();
            SendWorldPacket(CMSG_GROUP_DECLINE,NULL);
        }


		//...
		
		default: {
			DEBUG1(printf("Recieved unknown opcode=%u [%s] pktlen=%u\n",opcode,LookupName(opcode,g_worldOpcodeNames),data.size()););
		} break;		
		
	}
	
}